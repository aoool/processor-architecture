; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №1 по курсу Программирование на языке ассемблера				;
;	Вариант №10.																		;
;	Выполнил студент Морозов С. Группа 344												;
;																						;
;	Исходный модуль Lab1Func_Morozov_10.asm												;
;	Содержит функцию на языке ассемблера, разработанную в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание:																			;
;		Реализовать преобразование изображения с использованием оператора Лапласа.		;
; -------------------------------------------------------------------------------------	;

.DATA
_0         qword 0000000000000000h          ; Константа 0
_FF        qword 00000000000000FFh          ; Константа FF

.CODE
; -------------------------------------------------------------------------------------	;
; Осуществляет фильтрацию одной цветовой составляющей изображения						;
; void Filter_asm( char* pDst, char* pSrc, int Width, int Height  )						;
; Параметры:																			;
;	pDst   - адрес матрицы пикселов, в которую необходимо поместить результат обработки	;
;   pSrc   - адрес матрицы пикселов исходного изображения								;
;	Width  - ширина изображения в пикселах (количество столбцов)						;
;   Height - высота изображения в пикселах (количество строк)							;
; -------------------------------------------------------------------------------------	;
Filter_asm PROC	; [RCX] - pDst
				; [RDX] - pSrc
				; R8    - Width
				; R9    - Height

	push	rsi ; Сохранение регистров 
	push	rdi ;  которые будут использоваться в вычислениях
	push    r12 ;
	push    r13 ;

	mov		rsi,        rdx      ; Адрес пиксела-источника
	mov		rdi,        rcx      ; Адрес пиксела-приемника
	mov     r10,        r8       ; Вычисление произведения
	imul    r10,        r9       ;		вида Width * Height =: r12
	mov     r12,        r10      ;
	mov     r10,        rdx      ; Вычисление по формуле
	add     r10,        r12      ;		pSrc + Height * Width - Width
	sub     r10,        r8       ;
	mov     r13,        r10      ; Адрес первого пиксела последней строки входной матрицы (в r13)

	; Копирование первой строки пикселов
	mov		rcx, r8  ; Длина строки пикселов
	cld				 ; Направление копирования (с приращением адреса)
	rep movsb	     ; Копирование первой строки

	; Перебор и обработка всех пикселов, за исключением верхней и нижней строки пикселов
	m1:
		cmp rsi, r13            ; Перебираем пикселы, пока не дойдем до
		je m4                   ;	последнего пиксела предпоследней строки
		mov r10, 1              ; r10 - Счетчик пикселов текущей строки
	m2:
		cmp       r10, 1         ; Если пиксел - первый пиксел текущей строки,
		je        Copy_fPixel    ;	то просто скопируем его
		cmp       r10, r8        ; Если пиксел - последний пиксел текущей строки,
		je        Copy_lPixel    ;	то просто скопируем его
		
		; Обработка внутренних пикселов
		mov    rax, 0                  ; В rax будет сумматором, в котором в итоге окажется значение для текущего rdi 
									   ;	(текущего пиксела к которому применяем ядро)
		mov    rdx, rsi                ; Менять будем rdx, а rsi трогать не будем пока применяем ядро
		
		; Угловые значения матрицы фильтра Лапласа равны нулю,
		;	поэтому в целях оптимизации они не просчитываются в программе, т.к. результат умножения заведомо равен 0
		sub    rdx, r8                 ; Адрес верхнего-среднего
		inc    rdx                     ;	пиксела относительно текущего
		mov    r11, [rdx]              ; Извлекаем значение этого пиксела
		and    r11, 00000000000000FFh  ; Обнуляем все, кроме младшего байта, ибо цвета пикселов задаются значением типа unsigned char
		imul   r11, 1                  ; mult := верхний-средний_пиксел * mtrxKernel[0][1]
		add    rax, r11                ; rax += mult

		add    rdx, r8                 ; Адрес текущего пиксела
		mov    r11, [rdx]              ; Извлекаем значение этого пиксела
		and    r11, 00000000000000FFh  ; Обнуляем все, кроме младшего байта, ибо цвета пикселов задаются значением типа unsigned char
		imul   r11, -4                 ; mult := текущий_пиксел * mtrxKernel[1][1]
		add    rax, r11                ; rax += mult

		dec    rdx                     ; Адрес левого-среднего пиксела относительно текущего
		mov    r11, [rdx]              ; Извлекаем значение этого пиксела
		and    r11, 00000000000000FFh  ; Обнуляем все, кроме младшего байта, ибо цвета пикселов задаются значением типа unsigned char
		imul   r11, 1                  ; mult := средний-левый_пиксел * mtrxKernel[1][0]
		add    rax, r11                ; rax += mult

		add    rdx, 2                  ; Адрес правого-среднего пиксела относительно текущего
		mov    r11, [rdx]              ; Извлекаем значение этого пиксела
		and    r11, 00000000000000FFh  ; Обнуляем все, кроме младшего байта, ибо цвета пикселов задаются значением типа unsigned char
		imul   r11, 1                  ; mult := средний-правый_пиксел * mtrxKernel[1][2]
		add    rax, r11                ; rax += mult

		add    rdx, r8                 ; Адрес правого-среднего
		dec    rdx                     ;	пиксела относительно текущего
		mov    r11, [rdx]              ; Извлекаем значение этого пиксела
		and    r11, 00000000000000FFh  ; Обнуляем все, кроме младшего байта, ибо цвета пикселов задаются значением типа unsigned char	
		imul   r11, 1                  ; mult := нижний-средний_пиксел * mtrxKernel[2][1]
		add    rax, r11                ; rax += mult

		cmp    rax,     _0                 ; Если после применения ядра старший бит = 1 (т.е. значение цвета < 0),
		cmovl  rax,     _0                 ;	то установим rax в 0
		cmp    rax,     _FF                ; Если после применения ядра значение цвета > 255,
		cmovg  rax,     _FF                ;	то установим rax в FF

	    mov    [rdi],   al                ; Запись отфильтрованного пикселя в выходную матрицу
		inc    rsi                        ; pSrc++
		inc    rdi                        ; pDst++
	m3:
		inc       r10           ; Индекс_пиксела_относительно_текущей_строки++
		jmp       m2            ; Продолжаем обрабатывать внутренние пикселы

	; Копирование одиночного пиксела, первом столбце
	Copy_fPixel:                
		mov       rcx, 1        ; 
		cld                     ;
		rep movsb               ;
		jmp       m3            ;  

	; Копирование одиночного пиксела, последнем столбце
	Copy_lPixel:                
		mov       rcx, 1        ; 
		cld                     ;
		rep movsb               ;
		jmp       m1            ; Начинаем обработку новой строки

	m4:
	; Копирование последней строки пикселов
	mov		rcx, r8  ; Длина строки пикселов
	cld				 ; Направление копирования (с приращением адреса)
	rep movsb	     ; Копирование последней строки

	pop     r13
	pop     r12
	pop		rdi
	pop		rsi	
	ret
Filter_asm ENDP
END

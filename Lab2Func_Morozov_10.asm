; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №2 по курсу Программирование на языке ассемблера				;
;	Вариант №10.																		;
;	Выполнил студент Морозов С. Группа 344												;
;																						;
;	Исходный модуль Lab2Func_Morozov_10.asm												;
;	Содержит функцию на языке ассемблера, разработанную в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание:																			;
;		Реализовать преобразование изображения с использованием оператора Лапласа 		;
;       с помощью технологии AVX.                                                       ;
; -------------------------------------------------------------------------------------	; 

.CODE
; -------------------------------------------------------------------------------------	;
; Осуществляет фильтрацию одной цветовой составляющей изображения						;
; void Filter_asm( char* pDst, char* pSrc, int Width, int Height  )						;
; Параметры:																			;
;	pDst   - адрес матрицы пикселов, в которую необходимо поместить результат обработки	;
;   pSrc   - адрес матрицы пикселов исходного изображения								;
;	Width  - ширина изображения в пикселах (количество столбцов)						;
;   Height - высота изображения в пикселах (количество строк)							;
; -------------------------------------------------------------------------------------	;
Filter_asm PROC	; [RCX] - pDst
				; [RDX] - pSrc
				; R8    - Width
				; R9    - Height

	vzeroall    ; Обнуление всех YMM для увеличения производительности
	            ;   в соответствии с рекомендациями Intel
	push	rsi ; Сохранение регистров 
	push	rdi ;  которые будут использоваться в вычислениях
	push    rbx ;

	mov     rsi,        rdx      ; Адрес пиксела-источника (используется для обработки границ изображения)
	mov     rdi,        rcx      ; Адрес пиксела-приемника (используется для обработки границ изображения)
	mov     r10,        r8       ; Вычисление произведения
	imul    r10,        r9       ;		вида Width * Height =: r9
	mov     r9,         r10      ;
	mov     r10,        rdx      ; Вычисление по формуле
	add     r10,        r9       ;		pSrc + Height * Width - 2 * Width - 10
	sub     r10,        r8       ;
	sub     r10,        r8       ;
	sub     r10,        10       ; Адрес первого из последних 8-ми пикселов,
	                             ;   обрабатываемых векторно (в r10)

	; Начинаем применять ядро фильтра Лапласа для всех пикселов, кроме первой и последней строки пикселов.
	; В процессе посчитаются и значения для крайних пикелов, к которым ядро неприменимо.
	; Но после использования AVX команд мы просто скопируем все крайние пиксели в pDst, поэтому
	;   ничего страшного в том, что временно в крайних пикселах будут неправильные значения нет
	;   (зато повысим производительность вычислений).
	cmp    rdx, r10                ; Если команда выработает флаг равенства rdx и r10, то мы выйдем из цикла
	                               ;   командой je m2 и обработаем внешние пикселы
	je    m2                       ; Если rdx == r10, то сразу идем обработать внешние пикселы	  
	m1:			
		 ; Параллельная обработка внутренних пикселов

		 ; AVX первой версии не позволяет работать с целыми числами,
		 ;   будем выделять под каждый пиксель по 32 бита

		 ; Восемь пикселов, соответствующих верхнему пикселу ядра
         vmovq xmm3, qword ptr [rdx + 1]          ; Записываем 8 пикселей в XMM3
         vpmovzxbd xmm2, xmm3                     ; Пересылаем с расширением из XMM3 в XMM2 последние четыре пиксела,
                                                  ; теперь данные имеют формат dword
         vcvtdq2ps xmm2, xmm2                     ; Преобразовываем во float
         vpshufd xmm3, xmm3, 00000001b            ; Записываем левую часть XMM3 в правую для работы с первыми 4 пикселами.
         vpmovzxbd xmm4, xmm3                     ; Пересылка с расширением в XMM4
         vcvtdq2ps xmm4, xmm4                     ; Конвертация для применения VPERM2F128
         vperm2f128 ymm2, ymm2, ymm4, 100000b     ; Пересылаем XMM4 в старшую часть YMM2 с сохранением
                                                  ; младшей части YMM2 без изменений
         vmovdqu ymm0, ymm2                       ; В YMM0 хранится текущая сумма пикселей. Всего 8 пикселей в формате float
		                                          ;   Результат_пиксел += Верхний_пиксел * 1


		 ; Восемь пикселов, соответствующих левому пикселу ядра
         vmovq xmm3, qword ptr [rdx + r8]         ; Записываем 8 пикселей в XMM3
         vpmovzxbd xmm2, xmm3                     ; Пересылаем с расширением из XMM3 в XMM2 последние четыре пиксела,
                                                  ; теперь данные имеют формат dword
         vcvtdq2ps xmm2, xmm2                     ; Преобразовываем во float
         vpshufd xmm3, xmm3, 00000001b            ; Записываем левую часть XMM3 в правую для работы с первыми 4 пикселами.
         vpmovzxbd xmm4, xmm3                     ; Пересылка с расширением в XMM4
         vcvtdq2ps xmm4, xmm4                     ; Конвертация для применения VPERM2F128
         vperm2f128 ymm2, ymm2, ymm4, 100000b     ; Пересылаем XMM4 в старшую часть YMM2 с сохранением
                                                  ; младшей части YMM2 без изменений
         vaddps ymm0, ymm0, ymm2                  ; В YMM0 хранится текущая сумма пикселей. Всего 8 пикселей в формате float
		                                          ;   Результат_пиксел += Левый_пиксел * 1

		 
		 ; Восемь пикселов, соответствующих правому пикселу ядра
         vmovq xmm3, qword ptr [rdx + r8 + 2]     ; Записываем 8 пикселей в XMM3
         vpmovzxbd xmm2, xmm3                     ; Пересылаем с расширением из XMM3 в XMM2 последние четыре пиксела,
                                                  ; теперь данные имеют формат dword
         vcvtdq2ps xmm2, xmm2                     ; Преобразовываем во float
         vpshufd xmm3, xmm3, 00000001b            ; Записываем левую часть XMM3 в правую для работы с первыми 4 пикселами.
         vpmovzxbd xmm4, xmm3                     ; Пересылка с расширением в XMM4
         vcvtdq2ps xmm4, xmm4                     ; Конвертация для применения VPERM2F128
         vperm2f128 ymm2, ymm2, ymm4, 100000b     ; Пересылаем XMM4 в старшую часть YMM2 с сохранением
                                                  ; младшей части YMM2 без изменений
         vaddps ymm0, ymm0, ymm2                  ; В YMM0 хранится текущая сумма пикселей. Всего 8 пикселей в формате float
		                                          ;   Результат_пиксел += Правый_пиксел * 1



		 ; Восемь пикселов, соответствующих нижнему пикселу ядра
         vmovq xmm3, qword ptr [rdx + r8 * 2 + 1] ; Записываем 8 пикселей в XMM3
         vpmovzxbd xmm2, xmm3                     ; Пересылаем с расширением из XMM3 в XMM2 последние четыре пиксела,
                                                  ; теперь данные имеют формат dword
         vcvtdq2ps xmm2, xmm2                     ; Преобразовываем во float
         vpshufd xmm3, xmm3, 00000001b            ; Записываем левую часть XMM3 в правую для работы с первыми 4 пикселами.
         vpmovzxbd xmm4, xmm3                     ; Пересылка с расширением в XMM4
         vcvtdq2ps xmm4, xmm4                     ; Конвертация для применения VPERM2F128
         vperm2f128 ymm2, ymm2, ymm4, 100000b     ; Пересылаем XMM4 в старшую часть YMM2 с сохранением
                                                  ; младшей части YMM2 без изменений
         vaddps ymm0, ymm0, ymm2                  ; В YMM0 хранится текущая сумма пикселей. Всего 8 пикселей в формате float
		                                          ;   Результат_пиксел += Нижний_пиксел * 1


		 ; Восемь пикселов, соответствующих центральному пикселу ядра
         vmovq xmm3, qword ptr [rdx + r8 + 1]     ; Записываем 8 пикселей в XMM3
         vpmovzxbd xmm2, xmm3                     ; Пересылаем с расширением из XMM3 в XMM2 последние четыре пиксела,
                                                  ; теперь данные имеют формат dword
         vcvtdq2ps xmm2, xmm2                     ; Преобразовываем во float
         vpshufd xmm3, xmm3, 00000001b            ; Записываем левую часть XMM3 в правую для работы с первыми 4 пикселами.
         vpmovzxbd xmm4, xmm3                     ; Пересылка с расширением в XMM4
         vcvtdq2ps xmm4, xmm4                     ; Конвертация для применения VPERM2F128
         vperm2f128 ymm2, ymm2, ymm4, 100000b     ; Пересылаем XMM4 в старшую часть YMM2 с сохранением
                                                  ; младшей части YMM2 без изменений
         vsubps ymm0, ymm0, ymm2                  ; В YMM0 хранится текущая сумма пикселей. Всего 8 пикселей в формате float
		 vsubps ymm0, ymm0, ymm2                  ;   Результат_пиксел += Центральный_пиксел * (-4)
		 vsubps ymm0, ymm0, ymm2                  ; 
		 vsubps ymm0, ymm0, ymm2                  ; 


		 ; Конвертация в целые и упаковка
         ; AVX1 не поддерживает упаковку целых чисел на всём YMM, можно использовать только XMM,
         ; поэтому нужно Разделим YMM0 на XMM0 и XMM1
         vperm2f128 ymm1, ymm1, ymm0, 11b ; AVX1 не поддерживает vperm2i128 (т. е. для целых чисел),
		 vcvtps2dq ymm0, ymm0 ; значит, придётся конвертировать после "разбиения" числа
         vcvtps2dq ymm1, ymm1 ; на две части.

         ; Теперь в YMM0 и в YMM1 лежит по 4 распакованных пиксела в формате dword.

         vpackusdw xmm0, xmm0, xmm0; Упаковка значений сначала в word,
         vpackuswb xmm0, xmm0, xmm0; потом в byte.
         vpackusdw xmm1, xmm1, xmm1;
         vpackuswb xmm1, xmm1, xmm1;

         ; Теперь в младших частях XMM0 и XMM1 содержится по 4 байта-результата.
         ; Нельзя совместить их в рамках AVX перввого поколения, поэтому выгрузка в память производится с помощью регистров общего назначения
         vpextrd eax, xmm0, 0 ; Сохранение последних 4 пикселей в EAX (старшая часть RAX обнуляется)
         vpextrd ebx, xmm1, 0 ; Сохранение первых 4 пикселей в EBX (старшая часть RBX обнуляется)
         shl rbx, 32 ;
         add rax, rbx ;

         mov qword ptr [rcx + r8 + 1], rax   ; Сохранение результата в память

		 cmp   rdx, r10            ; Если это были последние 8 пикселов, к которым нужно применить ядро, то
		 je    m2                  ;   выходим из цикла для того, чтобы обработать внешние пикселы	  
		
	    add         rdx,   8              ; Мы только что обработали 8 пикселов 
		add         rcx,   8              ;   текущей строки	
		
		cmp    rdx, r10            ; Если (rdx - r10) > 0, то нужно сместиться назад и обработать последние 8 пикселов
		ja     last_pixels	       ; 

		jmp         m1                   ; Продолжаем обрабатывать пикселы

    last_pixels:
	    mov    r9,  r10      ; Считаем расницу между текущим положением источника и граничным положением, 
	    sub    r9,  rdx      ;   за которое нельзя заходить
		add    rdx, r9       ; Сдвигаемся назад на нужное количество пикселов
		add    rcx, r9       ;
		jmp    m1            ; Обработаем последние 8 пикселов и выйдем из цикла

	m2:
	; Копирование первой строки пикселов
	mov		rcx, r8  ; Длина строки пикселов
	cld				 ; Направление копирования (с приращением адреса)
	rep movsb	     ; Копирование первой строки

	mov    r9,  r8   ; Далее нам понадобится значение (Width - 2)
	sub    r9,  2    ;   для обработки границ изображения
	add    r10, r8   ; pSrc + Height * Width - Width
	add    r10, 10   ;
	m3:
	    ; Копирование первого пиксела текущей строки
		mov   rcx, 1        ;
		cld                 ;
		rep movsb           ;

		add   rsi,  r9       ; Теперь rsi и rdi указывают на последний пиксел текущей строки
		add   rdi,  r9       ;

		; Копирование последнего пиксела текущей строки
		mov   rcx, 1        ;
		cld                 ;
		rep movsb           ;

		cmp   rsi,  r10     ; Пока мы не добрались до послейней строки пикселов 
		jne   m3            ;   обрабатываем крайние

	; Копирование последней строки пикселов
	mov		rcx, r8  ; Длина строки пикселов 
	cld				 ; Направление копирования (с приращением адреса)
	rep movsb	     ; Копирование последней строки

	pop     rbx      ;
	pop		rdi      ;
	pop		rsi	     ;

	vzeroupper	; Очистка (и увеличение производительности
	            ;   в соответствии с рекомендациями Intel)
	ret
	Filter_asm ENDP
END


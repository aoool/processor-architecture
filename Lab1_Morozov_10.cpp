/* ------------------------------------------------------------------------------------	*\
	Лабораторная работа №1 по курсу Программирование на языке ассемблера
	Вариант №10.
	Выполнил студент Морозов С. Группа 344

	Исходный модуль Lab1cpp_Morozov_10.cpp

	Задание: 
		Реализовать преобразование изображения с использованием оператора Лапласа.
	
	void Filter_cpp( unsigned char* pDst, unsigned char* pSrc, int Width, int Height ) ;
	Параметры:
	pDst   - адрес матрицы пикселов, в которую необходимо поместить результат обработки
	pSrc   - адрес матрицы пикселов исходного изображения
	Width  - ширина изображения в пикселах (количество столбцов)	
	Height - высота изображения в пикселах (количество строк)
\* ------------------------------------------------------------------------------------  */

#include "stdafx.h"

//Матрица, определяющая ядро фильтра для оператора Лапласа
int mtrxKernel[3][3] = 
{
	{ 0,  1, 0 },
	{ 1, -4, 1 },
	{ 0,  1, 0 }
};

// Функция, осуществляющая слияние трех цветовых составляющих в 32-битное целое COLORREF
// Отличие от стандартного макроса RGB состоит в том, что цветовые составляющие имеют тип int, 
// а не char и перед сборкой производится проверка выхода значения пиксела за границы 0-255
// и привидение к минимальному/максимальному значению в случае выхода
inline COLORREF sRGB(int Red, int Green, int Blue)
{
	// Обработка переполнения. В результате операций цвета могли выйти за пределы 0...255
	if ( Red   > 0xFF ) Red   = 0xFF ;
	if ( Green > 0xFF ) Green = 0xFF ;
	if ( Blue  > 0xFF ) Blue  = 0xFF ;
	if ( Red   < 0 ) Red   = 0 ;
	if ( Green < 0 ) Green = 0 ;
	if ( Blue  < 0 ) Blue  = 0 ;
	// Сборка результата из цветов (вызов стандартного макроса)
	return RGB(Red, Green, Blue);
}



// Функция, осуществляющая преобразование олного пиксела изображения. Передаваемый пиксел умножается на
// центральный элемент элемент матрицы, а окружающие его пикселы на соответствующие элементы матрицы.
// Все девять произведений суммируются для получения пиксела-результата
COLORREF Kernel(unsigned char* Pixel, int Width) 
{
	int Red = 0, Green = 0, Blue = 0; //Три цвета результата
	//Умножение на элементы матрицы ядра окружающих пикселов поцветно
	for (int i = -1; i <= 1; i++)
		for (int j = -1; j <= 1; j++)
		{
			//Выбор пиксела из окружения
			UINT32 pix = *(Pixel - i * Width + j);
			//и умножение его на соответствующий элемент матрицы поцветно
			Red   += GetRValue(pix) * mtrxKernel[i + 1][j + 1];
			Green += GetGValue(pix) * mtrxKernel[i + 1][j + 1];
			Blue  += GetBValue(pix) * mtrxKernel[i + 1][j + 1];
		}
	//Сборка результата из цветов
	return sRGB(Red, Green, Blue);
}

void Filter_cpp( unsigned char* pDst, unsigned char* pSrc, int Width, int Height )
{
	memcpy(pDst, pSrc, Width); //Копирование первой строки пикселов 
	//Преобразование внутренних пикселов изображение фильтром Лапласа
	for (int i = 1; i < Height - 1; i++)
	{
		pDst[i * Width] = pSrc[i * Width]; //Копирование крайнего левого пиксела текущей строки пикселов
		pDst[(i + 1) * Width - 1] = pSrc[(i + 1) * Width - 1]; //Копирование крайнего правого пиксела текущей строки
		for (int j = 1; j < Width - 1; j++)
		{
			pDst[i * Width + j] = static_cast<unsigned char>(Kernel(pSrc + i * Width + j, Width));
		}
	}
	memcpy(pDst + Width * (Height - 1), pSrc + Width * (Height - 1), Width); //Копирование последней строки пикселов
}
